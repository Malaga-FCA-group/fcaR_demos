# Documentation
# https://malaga-fca-group.github.io/fcaR/index.html
# Installation:
# In the R console, use
# install.packages("fcaR")

# We load the library
library(fcaR)

# This is a sample dataset, with fuzzy values (0, 0.5 or 1)
# Object names are O1 to O6
# Attribute names are P1 to P6
# The matrix I will store the relationship.
objects <- paste0("O", 1:6)
n_objects <- length(objects)

attributes <- paste0("P", 1:6)
n_attributes <- length(attributes)

I <- matrix(data = c(0, 1, 0.5, 0, 0, 0.5,
                     1, 1, 0.5, 0, 0, 0,
                     0.5, 1, 0, 0, 1, 0,
                     0.5, 0, 0, 1, 0.5, 0,
                     1, 0, 0, 0.5, 0, 0,
                     0, 0, 1, 0, 0, 0),
            nrow = n_objects,
            byrow = FALSE)

colnames(I) <- attributes
rownames(I) <- objects


# We create a FormalContext variable storing the dataset above.
fc <- FormalContext$new(I)

# We can print the formal context
fc

# We can compute attribute concepts and object concepts:
fc$att_concept("P1")
fc$obj_concept("O1")

# Or compute the dual formal context
fc$dual()

# Since fcaR is designed for reproducible research, many of the classes include a "to_latex" method that exports its contents as LaTeX.
#Â For instance, we can print the table of the formal context with:
fc$to_latex(caption = "My caption",
            label = "tab:formal-context")

# We create a set of attributes to help in the next examples:
S <- Set$new(attributes = fc$attributes,
             P1 = 1, P3 = 0.5)
S

# The closure of S can be computed with:
fc$closure(S)


# Concepts
# Use NextClosure to compute the concept lattice
fc$find_concepts()

# This is the list of concepts:
fc$concepts

# We can plot the lattice:
fc$concepts$plot()
# Even remove the extents to make a simpler plot.
fc$concepts$plot(object_names = FALSE)

# Export the concept list to latex
fc$concepts$to_latex()

# Top and bottom of the lattice:
fc$concepts$bottom()
fc$concepts$top()

# Irreducible elements:
fc$concepts$join_irreducibles()
fc$concepts$meet_irreducibles()

# They can also be exported to latex
fc$concepts$meet_irreducibles()$to_latex()

# Concept support
fc$concepts$support()

# We can compute the sublattice generated by all those concepts
# with support greater than 0.4
sublattice <- fc$concepts$sublattice(fc$concepts$support() > 0.4)

# And plot it.
sublattice$plot(object_names = FALSE)

# Just a subset of the concepts:
fc$concepts[2:3]

# A single concept, the number 5 in the list.
C <- fc$concepts$sub(5)
C

# Its subconcepts and superconcepts
fc$concepts$subconcepts(C)
fc$concepts$superconcepts(C)

# Supremum and infimum of concepts number 16 and 17
fc$concepts$supremum(16:17)
fc$concepts$infimum(16:17)


# Only when concepts are computed, we can compute the standard
# context associated to our formal context:
fc$standardize()

# Last part: working with implications:
# We use the NextClosure (fuzzy version) to find the canonical basis
fc$find_implications()
# The basis:
fc$implications

# This is a simple copy of the basis:
imps <- fc$implications$clone()
imps

# That can be exported to latex
imps$to_latex()

# Or we can filter it imposing restrictions on the attributes
# to appear in the LHS and the RHS.
imps$filter(lhs = c("P1", "P2"),
            rhs = "P5")

# We can compute the semantic closure of the set S above
# with respect to the implications:
imps$closure(S, reduce = TRUE)

# This closure is computed using the Simplification Logic
# which also enables us to compute equivalent sets of implications:
imps2 <- imps$clone()
imps2$apply_rules(rules = c("simplification",
                            "rsimplification"))

imps2

# To check that imps2 is equivalent to imps:
imps2 %~% imps

# This is equivalent to test:
imps %entails% imps2
imps2 %entails% imps

# We can also check that no subset of the canonical basis
# is equivalent to it, For instance, just taking the first
# five implications are not equivalent:
imps[1:5] %entails% imps

# To check if a set of implications hold in a formal context, 
# we use:
imps %holds_in% fc

